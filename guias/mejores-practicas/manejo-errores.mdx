---
title: "Manejo de Errores"
description: "Como manejar errores correctamente con pan API"
---

## Estructura de Errores

```json
{
  "error": "ERROR_CODE",
  "message": "Descripción legible",
  "details": {
    "campo": "valor"
  }
}
```

## Errores Comunes

### Autenticación

| Código | Causa | Solución |
|--------|-------|----------|
| `UNAUTHORIZED` | API key inválida | Verificar API key |

### Validación

| Código | Causa | Solución |
|--------|-------|----------|
| `VALIDATION_ERROR` | Datos inválidos | Verificar parámetros |
| `UNSUPPORTED_ACTION` | Acción no soportada | Usar lend/withdraw/bridge |
| `INVALID_NETWORK` | Network no soportada | Usar mainnet/testnet |

### Recursos

| Código | Causa | Solución |
|--------|-------|----------|
| `NOT_FOUND` | Recurso no existe | Verificar walletId o intentId |
| `WALLET_LIMIT_EXCEEDED` | Límite de plan | Upgrade |

### Ejecución

| Código | Causa | Solución |
|--------|-------|----------|
| `PLANNING_ERROR` | No se pudo planificar | Verificar fondos suficientes |
| `INTERNAL_ERROR` | Error interno | Reintentar |

## Patron de Manejo

```typescript
import { Pan, PanError } from '@odisea-labs/pan';

async function ejecutar<T>(fn: () => Promise<T>): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    if (error instanceof PanError) {
      return manejarErrorPan(error);
    }
    throw error;
  }
}

function manejarErrorPan(error: PanError): never {
  switch (error.code) {
    // Errores de validación
    case 'VALIDATION_ERROR':
    case 'UNSUPPORTED_ACTION':
    case 'INVALID_NETWORK':
      throw new ValidationError(error.message);

    // Recurso no encontrado
    case 'NOT_FOUND':
      throw new NotFoundError(error.message);

    // Errores de configuración
    case 'UNAUTHORIZED':
      throw new ConfigError('API key invalida');

    case 'WALLET_LIMIT_EXCEEDED':
      throw new LimitError('Actualiza tu plan para más wallets');

    // Errores de planificación/ejecución
    case 'PLANNING_ERROR':
      throw new ValidationError(error.message);

    // Errores de servidor
    case 'INTERNAL_ERROR':
      throw new ServerError('Intenta más tarde');

    default:
      throw error;
  }
}
```

## Reintentos Automáticos

```typescript
async function conReintentos<T>(
  fn: () => Promise<T>,
  maxReintentos = 3
): Promise<T> {
  const erroresReintentables = [
    'INTERNAL_ERROR'
  ];

  for (let i = 0; i < maxReintentos; i++) {
    try {
      return await fn();
    } catch (error) {
      if (!(error instanceof PanError)) throw error;
      if (!erroresReintentables.includes(error.code)) throw error;

      const espera = Math.pow(2, i) * 1000; // Backoff exponencial
      console.log(`Reintento ${i + 1}/${maxReintentos} en ${espera}ms...`);
      await new Promise(r => setTimeout(r, espera));
    }
  }

  throw new Error('Reintentos agotados');
}

// Uso
const wallet = await conReintentos(() =>
  pan.wallet.create({ userId: 'user_123' })
);
```

## Manejo por Operación

### Crear Wallet

```typescript
async function crearWalletSeguro(userId: string) {
  try {
    return await pan.wallet.create({ userId });
  } catch (error) {
    if (!(error instanceof PanError)) throw error;

    switch (error.code) {
      case 'WALLET_LIMIT_EXCEEDED':
        throw new Error('Limite alcanzado. Contacta soporte.');

      default:
        throw error;
    }
  }
}
```

### Ejecutar Intent

```typescript
async function ejecutarIntent(params: LendParams) {
  // 1. Verificar fondos primero
  const balances = await pan.wallet.getBalances(params.walletId);
  const disponible = calcularTotal(balances, params.asset);

  if (disponible < params.amount) {
    throw new Error(
      `Fondos insuficientes. Tienes ${disponible}, necesitas ${params.amount}`
    );
  }

  // 2. Crear intent
  try {
    const intent = await pan.lend(params);
    return await esperarIntent(intent.id);
  } catch (error) {
    if (!(error instanceof PanError)) throw error;

    switch (error.code) {
      case 'PLANNING_ERROR':
        // No se pudo planificar, verificar fondos
        throw new Error('No se pudo planificar. Verifica tus fondos.');

      case 'INTERNAL_ERROR':
        // Error interno, se puede reintentar
        console.log('Error interno, reintentando...');
        return ejecutarIntent(params);

      default:
        throw error;
    }
  }
}
```

## Errores en UI

```tsx
function ErrorDisplay({ error }: { error: PanError }) {
  const mensajes: Record<string, { titulo: string; accion?: string }> = {
    VALIDATION_ERROR: {
      titulo: 'Datos inválidos',
      accion: 'Verifica los datos ingresados'
    },
    NOT_FOUND: {
      titulo: 'Recurso no encontrado',
      accion: 'Verifica el ID'
    },
    PLANNING_ERROR: {
      titulo: 'No se pudo planificar',
      accion: 'Verifica tus fondos'
    },
    UNAUTHORIZED: {
      titulo: 'Error de autenticación',
      accion: 'Contacta soporte'
    }
  };

  const info = mensajes[error.code] || {
    titulo: 'Error inesperado',
    accion: 'Intenta de nuevo'
  };

  return (
    <div className="error-card">
      <h3>{info.titulo}</h3>
      <p>{error.message}</p>
      {info.accion && <p className="action">{info.accion}</p>}
    </div>
  );
}
```

## Logging de Errores

```typescript
function logError(error: PanError, context: object) {
  const logData = {
    timestamp: new Date().toISOString(),
    code: error.code,
    message: error.message,
    statusCode: error.statusCode,
    details: error.details,
    context: sanitize(context) // Remover datos sensibles
  };

  // Enviar a servicio de monitoreo
  if (process.env.NODE_ENV === 'production') {
    sendToMonitoring(logData);
  } else {
    console.error('pan Error:', logData);
  }
}

function sanitize(obj: object): object {
  const sensibles = ['apiKey', 'token', 'password'];
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [
      k,
      sensibles.includes(k) ? '[REDACTED]' : v
    ])
  );
}
```
